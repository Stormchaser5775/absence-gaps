{"id": 0, "subset": "github_prs", "predicted": ["Line::create(['order_id' => $order->id, 'product_id' => $product2->id]);", "$serialized = serialize(new ModelRelationSerializationTestClass($order));"], "ground_truth": ["+        Line::create(['order_id' => $order->id, 'product_id' => $product2->id]);", "+        $serialized = serialize(new ModelRelationSerializationTestClass($order));", "+    public $timestamps = false;"], "precision": 0.0, "recall": 0.0, "f1": 0}
{"id": 1, "subset": "github_prs", "predicted": ["-                $model->autoloadRelationsUsing($callback);", "DB::enableQueryLog();", "DB::disableQueryLog();", "-        $this->propagateRelationAutoloadCallbackToRelation($relation, $value, $this);"], "ground_truth": ["-                $model->autoloadRelationsUsing($callback);", "+                $model->autoloadRelationsUsing($callback, $this);", "+        }"], "precision": 0.25, "recall": 0.3333333333333333, "f1": 0.28571428571428575}
{"id": 2, "subset": "github_prs", "predicted": ["     ]),", "     }", "}", "$this->assertEquals('foo bar baz', FactoryTestPost::first()->title);", "$this->assertEquals('other title', FactoryTestPost::first()->title);", "(new FactoryTestPostFactory())->has(new FactoryTestCommentFactory(), 'commentsWithFooBarBazAsBody')->create();", "(new FactoryTestPostFactory())->has((new FactoryTestCommentFactory())->state(['body' => 'other body']), 'commentsWithFooBarBazAsBody')->create();"], "ground_truth": ["+            'states' => $this->states->prepend(", "+    public function test_factory_model_has_one_relationship_has_pending_attributes_override()", "+        (new FactoryTestPostFactory())->has(new FactoryTestCommentFactory(), 'commentsWithFooBarBazAsBody')->create();", "+        (new FactoryTestPostFactory())->has((new FactoryTestCommentFactory())->state(['body' => 'other body']), 'commentsWithFooBarBazAsBody')->create();", "+        return $this->hasOne(FactoryTestPost::class, 'user_id')->withAttributes(['title' => 'foo bar baz']);"], "precision": 0.0, "recall": 0.0, "f1": 0}
{"id": 3, "subset": "github_prs", "predicted": ["public function testItCanAssertMarkdownEncodedStringUsingTemplateWithTable($given, $expected)", "public static function markdownEncodedTemplateDataProvider()"], "ground_truth": ["+    protected $html;", "+| Laravel       | Table         | Example       |"], "precision": 0.0, "recall": 0.0, "f1": 0}
{"id": 4, "subset": "github_prs", "predicted": ["public function testWhenRelationIsNull()"], "ground_truth": ["+    public function testWhenRelationIsNull()"], "precision": 0.0, "recall": 0.0, "f1": 0}
{"id": 5, "subset": "github_prs", "predicted": ["try {", "} finally {", "EncodedHtmlString::flushState();", "return $contents;"], "ground_truth": ["+                    $contents = $this->view->replaceNamespace(", "+                }", "+                return $contents;", "+            str_replace('\\[', '[', $contents), $this->view->make($theme, $data)->render()", "+        }", "+            public function build()"], "precision": 0.0, "recall": 0.0, "f1": 0}
{"id": 6, "subset": "github_prs", "predicted": ["     */", "     * @return $this", "         return $this;", "         $this->assertFalse(Job::$ran);", "         $this->app->terminate();", "         Job::$ran = false;", "         Job::dispatchAfterResponse('test');", "         $this->assertTrue(Job::$ran);", "         $this->app->terminate();", "         $this->assertTrue(Job::$ran);"], "ground_truth": [], "precision": 0, "recall": 0, "f1": 0}
{"id": 7, "subset": "github_prs", "predicted": ["use Illuminate_notifications_Events_NotificationFailed;", "use Illuminate_Support_Traits_Localizable;"], "ground_truth": ["+    public function testNotificationNotSentWhenFailed()", "+        $container->instance(Dispatcher::class, $events = m::mock(Dispatcher::class));", "+            foreach ($listeners as $listener) {"], "precision": 0.0, "recall": 0.0, "f1": 0}
{"id": 8, "subset": "github_prs", "predicted": ["$table->increments('id');", "if (! array_key_exists($relation, $this->relations)) {", "return false;", "}", "Schema::create('ones', function (Blueprint $table) {", "$table->increments('id');", "public function one(): BelongsTo", "    return $this->belongsTo(One::class, 'one_id');", "}"], "ground_truth": ["+        if (! array_key_exists($relation, $this->relations)) {", "+                    return false;", "+                }", "+use Illuminate\\Support\\Facades\\Schema;", "+        $this->assertFalse($model->relationLoaded('invalid'));", "+        $this->assertFalse($model->relationLoaded('twos.invalid'));"], "precision": 0.0, "recall": 0.0, "f1": 0}
{"id": 9, "subset": "github_prs", "predicted": ["$this->shouldCheckTimestamps = $shouldCheckTimestamps;", "$this->shouldCheckTimestamps) { return false; }"], "ground_truth": ["+     *", "+        $this->shouldCheckTimestamps = $shouldCheckTimestamps;", "+            return false;", "+        }", "+    }"], "precision": 0.0, "recall": 0.0, "f1": 0}
{"id": 10, "subset": "github_prs", "predicted": [], "ground_truth": ["+            $this->createPayload($job, $queue ?: $this->default, $data, $delay),", "+        $query->shouldReceive('insertGetId')->once()->andReturnUsing(function ($array) use ($uuid, $time) {", "+                'payload' => json_encode(['uuid' => $uuid, 'displayName' => 'foo', 'job' => 'foo', 'maxTries' => null, 'maxExceptions' => null, 'failOnTimeout' => false, 'backoff' => null, 'timeout' => null, 'data' => ['data'], 'createdAt' => $time->getTimestamp(), 'delay' => null]),", "+            json_encode(['uuid' => $uuid, 'displayName' => 'foo', 'job' => 'foo', 'maxTries' => null, 'maxExceptions' => null, 'failOnTimeout' => false, 'backoff' => null, 'timeout' => null, 'data' => ['data'], 'createdAt' => $time->getTimestamp(), 'id' => 'foo', 'attempts' => 0, 'delay' => 5])", "-        $queue->later($date, 'foo', ['data']);"], "precision": 0, "recall": 0.0, "f1": 0}
{"id": 11, "subset": "github_prs", "predicted": ["/**", "* Create a Collection of new instances of the related model, allowing mass-assignment.", "* @param  iterable  $records", "* @return \\Illuminate\\Database\\Eloquent\\Collection<int, TRelatedModel>", "*/", "/**", "* Create a Collection of new instances of the related model, allowing mass-assignment and without raising any events to the parent model.", "* @param  iterable  $records", "* @return \\Illuminate\\Database\\Eloquent\\Collection<int, TRelatedModel>", "*/", "return $instances;"], "ground_truth": ["+        return $instances;"], "precision": 0.0, "recall": 0.0, "f1": 0}
{"id": 12, "subset": "github_prs", "predicted": ["$this->files->put($compiledPath, $contents);", "$compiler = new BladeCompiler($files = $this->getFiles(), __DIR__);", "$files->shouldReceive('get')->once()->with('foo')->andReturn('Hello World');", "$files->shouldReceive('exists')->once()->with(__DIR__)->andReturn(true);"], "ground_truth": ["+            $compiledHash = $this->files->hash($compiledPath, 'sha256');"], "precision": 0.0, "recall": 0.0, "f1": 0}
{"id": 13, "subset": "github_prs", "predicted": ["$relatedModels = is_iterable($this->$relation)", "$this->assertTrue($model->relationLoaded('two'));", "$this->assertTrue($model->two->is($two));"], "ground_truth": ["+            $relatedModels = is_iterable($relatedModels = $this->$relation)", "+    {", "+        $this->assertTrue($model->relationLoaded('two'));", "+        $this->assertTrue($model->two->is($two));"], "precision": 0.0, "recall": 0.0, "f1": 0}
{"id": 14, "subset": "github_prs", "predicted": ["use function Illuminate\\Support\\enum_value;", "$response = TestResponse::fromBaseResponse(new Response([", "]));", "$response->assertJsonPath('data.status', TestStatus::Booked);"], "ground_truth": ["+use function Illuminate\\Support\\enum_value;", "+            'data' => ['status' => 'booked'],"], "precision": 0.0, "recall": 0.0, "f1": 0}
{"id": 15, "subset": "github_prs", "predicted": ["+", "+"], "ground_truth": ["+    {"], "precision": 0.0, "recall": 0.0, "f1": 0}
{"id": 16, "subset": "github_prs", "predicted": ["$memoValue = Cache::memo()->many(['a', '1.1', '1', 2]);", "$this->assertSame([", "'a' => 'string-value',", "'1.1' => 'float-value',", "'1' => 'integer-value-as-string',", "2 => 'integer-value',", "], $cacheValue);", "$this->assertSame($cacheValue, $memoValue);", "$memoValue = Cache::memo()->many(['a', '1.1', '1', 2]);", "$this->assertSame($cacheValue, $memoValue);"], "ground_truth": ["+        $this->assertSame(["], "precision": 0.0, "recall": 0.0, "f1": 0}
{"id": 17, "subset": "github_prs", "predicted": ["+    /**", "+     * Indicates if the job should be deleted when models are missing.", "+     *", "+     * @var bool", "+    */", "+    public $deleteWhenMissingModels;", "     */", "     * Create a new job handler instance.", "     */", "     * Create a new job instance."], "ground_truth": [], "precision": 0, "recall": 0, "f1": 0}
{"id": 18, "subset": "github_prs", "predicted": ["* @param  string  $attribute", "* @param  mixed  $value", "* @param  \\\\Closure(string, ?string=): \\\\Illuminate\\\\Translation\\\\PotentiallyTranslatedString  $fail", "* @return void"], "ground_truth": ["+use function PHPStan\\Testing\\assertType;", "+};"], "precision": 0.0, "recall": 0.0, "f1": 0}
{"id": 19, "subset": "github_prs", "predicted": ["    public $tags;", "    public function __construct($storeName, array $tags = [])", "    public function setTags($tags)"], "ground_truth": ["+     * Create a new event instance.", "+        } else {"], "precision": 0.0, "recall": 0.0, "f1": 0}
{"id": 20, "subset": "github_prs", "predicted": ["$post->tagsWithCustomPivot()->attach(Tag::all());", "$this->assertEquals(Tag::pluck('name'), $post->tags->pluck('name'));", "$post->load('tagsWithCustomPivot');", "$this->assertEquals(", "$post->load('tagsWithCustomPivot');", "$this->assertEquals("], "ground_truth": ["-            foreach ($this->parseIds($ids) as $id) {", "+        $post->tagsWithCustomPivot()->attach(Tag::all());", "+            Tag::whereNotIn('id', [$tag->id])->pluck('name'),"], "precision": 0.0, "recall": 0.0, "f1": 0}
{"id": 21, "subset": "github_prs", "predicted": ["use Illuminate\\Tests\\Integration\\Database\\DatabaseTestCase;", "$connection = $this->app['db']->connection();", "$handler = new DatabaseSessionHandler($connection, 'sessions', 1);", "$session = $connection->table('sessions')->first();", "Carbon::setTestNow(Carbon::now()->addSeconds(2));", "$this->assertEquals(1, $connection->table('sessions')->count());", "$this->assertEquals(2, $connection->table('sessions')->count());", "$this->assertEquals(1, $connection->table('sessions')->count());", "$this->assertEquals(0, $connection->table('sessions')->count());", "$this->assertEquals(1, $connection->table('sessions')->where('id', 'id_2')->count());", "$session = $connection->table('sessions')->first();", "$this->assertNull($session->user_id);"], "ground_truth": ["+use Illuminate\\Tests\\Integration\\Database\\DatabaseTestCase;", "+        $this->assertEquals(['come' => 'alive'], json_decode($handler->read('valid_session_id_2425'), true));", "+        $this->assertNull($session->user_id);"], "precision": 0.0, "recall": 0.0, "f1": 0}
{"id": 22, "subset": "github_prs", "predicted": ["use IlluminateSupportCarbon;", "Carbon::setTestNow(Carbon::parse('2025-02-02 01:30:00'));", "$minutesAgo30 = Carbon::parse('2025-02-02 01:00:00')->getTimestamp();", "$this->files->shouldReceive('isFile')->with($path)->andReturn(true);", "$this->files->shouldReceive('lastModified')->with($path)->andReturn($minutesAgo30);", "$path = '/path/to/sessions/'.$sessionId;", "$sessionId = 'session_id';", "$result = $this->sessionHandler->read($sessionId);", "$this->assertEquals('', $result);", "$result = $this->sessionHandler->write($sessionId, $data);", "$sessionId = 'session_id';", "$data = 'session_data';", "$this->assertTrue($result);", "$result = $this->sessionHandler->destroy($sessionId);", "$this->assertTrue($result);", "$this->files->shouldReceive('delete')->with(join_paths(__DIR__, 'tmp', 'a3'))->once()->andReturn(true);", "$this->assertEquals(2, $count);"], "ground_truth": ["+use Illuminate\\Support\\Carbon;", "+        // Create a mock for the Filesystem class", "+        Carbon::setTestNow(Carbon::parse('2025-02-02 01:30:00'));", "+        $result = $this->sessionHandler->write($sessionId, $data);", "+    public function test_destroy_deletes_session_file()", "+        $this->files->shouldReceive('delete')->with(join_paths(__DIR__, 'tmp', 'a3'))->once()->andReturn(true);", "+        // act:", "+        $this->assertEquals(2, $count);"], "precision": 0.0, "recall": 0.0, "f1": 0}
{"id": 23, "subset": "github_prs", "predicted": ["use PHPUnit\\Framework\\TestCase;", "public function test_open() { $this->assertTrue($result); }", "$this->assertTrue($result);", "$this->assertTrue($result);", "$this->assertTrue($result);"], "ground_truth": ["+use PHPUnit\\Framework\\TestCase;", "+    public function test_open()", "+        $this->cacheMock->shouldReceive('forget')->once()->with('session_id')->andReturn(true);", "+        $result = $this->sessionHandler->gc(lifetime: 120);"], "precision": 0.0, "recall": 0.0, "f1": 0}
{"id": 24, "subset": "github_prs", "predicted": ["if (is_array($value) && ! empty($value)) {", "}", "else {"], "ground_truth": ["-            } else {", "+                if (is_array($value) && ! empty($value)) {", "-        }"], "precision": 0.0, "recall": 0.0, "f1": 0}
{"id": 25, "subset": "github_prs", "predicted": ["$use = ltrim(trim($expression, \" '\"), '\\');", "return \"<?php use \\{$use}; ?>\";", "$expected = \"Foo <?php use \\\\SomeNamespace\\\\{Foo, Bar}; ?> bar\";", "$this->assertEquals($expected, $this->compiler->compileString($string));", "$this->assertEquals($expected, $this->compiler->compileString($string));", "$this->assertEquals($expected, $this->compiler->compileString($string));"], "ground_truth": ["-        $segments = explode(',', preg_replace(\"/[\\(\\)]/\", '', $expression));", "+            $use = ltrim(trim($expression, \" '\\\"\"), '\\\\');", "+            return \"<?php use \\\\{$use}; ?>\";", "+        $string = \"Foo @use('\\SomeNamespace\\{Foo, Bar}') bar\";"], "precision": 0.0, "recall": 0.0, "f1": 0}
{"id": 26, "subset": "github_prs", "predicted": ["if (Model::isAutomaticallyEagerLoadingRelationships()) {", "return $collection;"], "ground_truth": ["+        if (Model::isAutomaticallyEagerLoadingRelationships()) {", "+        return $collection;"], "precision": 0.0, "recall": 0.0, "f1": 0}
{"id": 27, "subset": "github_prs", "predicted": ["@param  string  $key", "@param  \\\\", "@param  int  $amount", "@return int", "@return int", "@param  int  $amount", "@return int", "@param  int  $amount", "@return int"], "ground_truth": ["+ * @method static int decrement(string $key, \\DateTimeInterface|\\DateInterval|int $decaySeconds = 60, int $amount = 1)"], "precision": 0.0, "recall": 0.0, "f1": 0}
{"id": 28, "subset": "github_prs", "predicted": ["$d = new Dispatcher($container = m::mock(Container::class));", "$broadcast = m::mock(BroadcastFactory::class);", "$broadcast->shouldReceive('queue')->once();", "$container->shouldReceive('make')->once()->with(BroadcastFactory::class)->andReturn($broadcast);", "$event = new class implements ShouldBroadcast {", "$d->dispatch($event);", "}", "}", "}", "}"], "ground_truth": ["+    public function testBroadcastWithCustomConnectionName()", "+                return 'custom-event-name';", "+                return ['custom' => $this->customData];"], "precision": 0.0, "recall": 0.0, "f1": 0}
{"id": 29, "subset": "github_prs", "predicted": ["$expected = \"Foo <?php use \\\\", "$this->assertEquals($expected, $this->compiler->compileString($string));", "$expected = \"Foo <?php use \\\\", "$this->assertEquals($expected, $this->compiler->compileString($string));", "$expected = \"Foo <?php use \\\\", "$this->assertEquals($expected, $this->compiler->compileString($string));", "$expected = \"Foo <?php use \\\\", "$this->assertEquals($expected, $this->compiler->compileString($string));"], "ground_truth": ["+        $string = \"Foo @use('\\SomeNamespace\\SomeClass', 'Foo') bar\";"], "precision": 0.0, "recall": 0.0, "f1": 0}
